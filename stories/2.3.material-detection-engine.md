# Story 2.3: Material Detection Engine (P0)

**Status:** Ready for Development

---

## Story

**As a** Backend Developer,
**I want** to implement the Material Detection Engine that identifies delivered materials (shingles, plywood, etc.), counts units, and detects brand information,
**so that** project managers and contractors can verify material deliveries and confirm quantities against orders.

---

## Acceptance Criteria

1. YOLOv8-based object detection model integrated for identifying materials (shingles, plywood, other building materials)
2. Object counting system implemented using density estimation CNN for accurate material unit counting
3. Brand/type detection implemented using OCR (Tesseract/Cloud Vision API) for identifying brand labels on materials
4. Material quantity validation logic implemented to compare detected vs. expected quantities
5. Alert generation for quantity discrepancies (underage alerts)
6. Bounding boxes generated for each detected material unit with confidence scores
7. Inference latency < 450ms for typical delivery photos (P95)
8. Batch processing capability for processing multiple delivery photos efficiently
9. Model versioning and version tracking in detection results
10. Output standardized with material detection response schema

---

## Dev Notes

### Architecture Context
- **Service Type**: Python FastAPI microservice with GPU inference support [Source: architecture.md#4.6.2-Material-Detection-Engine]
- **Inference Infrastructure**: GPU instances (AWS EC2 P3/P4) for model serving [Source: architecture.md#6.2-AI/ML-Infrastructure]
- **Model Serving**: TorchServe or TensorFlow Serving for production inference [Source: architecture.md#6.2-AI/ML-Infrastructure]
- **OCR Services**: Tesseract (self-hosted) or AWS Textract/Google Cloud Vision API for brand detection
- **Deployment**: Kubernetes with GPU node pools for auto-scaling [Source: architecture.md#10.2-Infrastructure-as-Code]

### Detection Engine Specifications
From architecture.md#4.6.2:
- **Capabilities**: Detect shingles, plywood, and other materials; count identifiable units; identify brand/type
- **Counting Method**: Density estimation CNN for accurate unit counting
- **Brand Detection**: OCR for identifying brand labels
- **Output**: Bounding boxes, material counts, confidence scores, brand information
- **Models**:
  - Object Detection: YOLOv8
  - Object Counting: Density Estimation CNN
  - OCR: Tesseract or Cloud Vision API

### Response Schema
**Output Format:**
```json
{
  "materials": [
    {
      "type": "shingles",
      "brand": "CertainTeed",
      "count": 35,
      "confidence": 0.88,
      "unit": "bundles",
      "expected_quantity": 36,
      "alert": null,
      "bounding_boxes": [
        {
          "x": 100,
          "y": 150,
          "width": 80,
          "height": 100,
          "confidence": 0.91
        }
      ]
    },
    {
      "type": "plywood",
      "brand": "Weyerhaeuser",
      "count": 24,
      "confidence": 0.85,
      "unit": "sheets",
      "expected_quantity": 25,
      "alert": {
        "type": "underage",
        "message": "Expected 25 sheets but detected 24 sheets",
        "variance_percentage": -4
      },
      "bounding_boxes": []
    }
  ],
  "tags": ["delivery_confirmation", "shingles", "plywood"],
  "summary": {
    "total_materials_detected": 2,
    "total_units": 59,
    "discrepancy_alerts": 1
  },
  "processing_time_ms": 420,
  "model_version": "material-v1.1.0",
  "confidence": 0.87
}
```

### Model Details
**Object Detection Model (YOLOv8):**
- Input: 640x640 RGB images
- Output: Bounding boxes with class probabilities
- Classes: shingles, plywood, drywall, insulation, other_materials
- Training data: Delivery photo imagery with various material types
- Inference time: 120-160ms per image

**Counting Model (Density Estimation CNN):**
- Input: 256x256 patches from detected regions
- Output: Density map showing material unit locations
- Used for accurate counting of overlapping/stacked materials
- Inference time: 80-120ms per region

**OCR/Brand Detection:**
- Use Tesseract locally or AWS Textract for cloud processing
- Extract text from labeled regions on materials
- Match extracted text against known brand database
- Confidence scoring based on OCR confidence

### Technical Implementation Details

**Material Database**: [Source: architecture.md#4.6.2-Material-Detection-Engine]
- Create reference database of known materials and brands
- Include material types (shingles, plywood, drywall, insulation)
- Known brands for each material type
- Material-specific unit definitions (bundles, sheets, bags, etc.)

**Counting Logic**:
- YOLOv8 detects individual units with bounding boxes
- Density estimation refines counts for clustered materials
- Implement IoU (Intersection over Union) to avoid double-counting
- Post-processing to merge nearby detections and count accurately

**Quantity Validation**: [Source: architecture.md#4.6.2-Material-Detection-Engine]
- Compare detected count against expected_quantity (optional parameter)
- Calculate variance percentage
- Generate alerts for significant discrepancies (configurable threshold)
- Alert types: underage, overage, quantity_mismatch

**Brand Detection Pipeline**:
- Crop regions around detected materials
- Apply OCR (Tesseract or cloud API)
- Parse extracted text using fuzzy matching
- Match against known brands database
- Assign confidence score based on OCR and matching confidence

**File Structure**
```
backend/src/
├── ai_models/
│   ├── material_detection/
│   │   ├── detector.py              # YOLOv8 wrapper
│   │   ├── counter.py               # Density estimation wrapper
│   │   ├── brand_detector.py        # OCR and brand detection
│   │   ├── material_validator.py    # Quantity validation logic
│   │   ├── pipeline.py              # End-to-end detection pipeline
│   │   ├── config.py                # Model configuration
│   │   └── material_database.py     # Material/brand reference data
│   └── model_loader.py              # Model loading and caching
├── services/
│   └── material_detection_service.py # Service logic
├── schemas/
│   └── material_detection_schema.py  # Response schemas
└── api/
    └── material_detection_routes.py  # gRPC endpoints

backend/tests/
├── test_material_detector.py         # YOLOv8 model tests
├── test_material_counter.py          # Counting model tests
├── test_brand_detector.py            # OCR and brand detection tests
├── test_quantity_validation.py       # Quantity validation tests
└── test_material_pipeline.py         # End-to-end pipeline tests

backend/data/
├── materials.json                    # Material type definitions
└── brands.json                       # Brand database reference
```

### Dependencies
- torch >= 2.0.0 with CUDA support
- ultralytics >= 8.0 (YOLOv8)
- torchvision >= 0.15.0 for custom models
- OpenCV >= 4.6 for image processing
- Pillow for image operations
- pytesseract for OCR (if using Tesseract)
- boto3 for AWS Textract (if using cloud OCR)
- fuzzywuzzy for fuzzy string matching
- NumPy for numerical operations

### Integration Points
- **Input**: AI Orchestrator (gRPC) with photo URLs from S3
- **Output**: Material detection results to Orchestrator
- **OCR**: Tesseract (local) or AWS Textract/Google Vision API (cloud)
- **Cache**: Redis for caching brand database and detection results
- **Database**: PostgreSQL for storing material reference data
- **Monitoring**: Prometheus metrics for model performance

### Performance Targets
- **Inference Latency**: < 450ms P95 for typical delivery photos [Source: architecture.md#9.1-Performance-Targets]
- **Counting Accuracy**: High correlation with manual counts (target > 95%)
- **Brand Detection**: High precision for known brands (target > 90%)
- **Throughput**: Support 100+ concurrent requests

### Testing Standards
- **Test Framework**: pytest with GPU test fixtures
- **Unit Tests**: Model loading, preprocessing, counting, OCR (>80% coverage)
- **Integration Tests**: End-to-end pipeline with real delivery photos
- **Performance Tests**: Latency benchmarking on various image sizes
- **Edge Case Tests**: Overlapping materials, partial views, poor lighting
- **Accuracy Tests**: Compare detected counts with ground truth
- **Test Locations**: `/backend/tests/test_material_*.py`
- **GPU Availability**: Tests should gracefully skip if GPU unavailable
- **Test Data**: Use sample delivery photos with known material counts
- **Test Execution**: `pytest backend/tests/test_material_*.py -v --benchmark`

---

## Tasks / Subtasks

- [ ] Set up material detection service infrastructure (AC: 1, 9)
  - [ ] Create FastAPI service with health check endpoints
  - [ ] Implement model configuration management
  - [ ] Set up GPU memory management
  - [ ] Create model version tracking system
  - [ ] Add service logging with structured output

- [ ] Create material reference database (AC: 1, 5, 10)
  - [ ] Design material types schema (shingles, plywood, drywall, etc.)
  - [ ] Create brand database with known material brands
  - [ ] Implement material database loader
  - [ ] Add database query interface
  - [ ] Populate with common material types and brands
  - [ ] Unit tests for database operations

- [ ] Integrate YOLOv8 object detection model (AC: 1, 6)
  - [ ] Load pre-trained YOLOv8 model (fine-tuned for materials)
  - [ ] Implement image preprocessing pipeline
  - [ ] Create detection inference wrapper
  - [ ] Implement confidence threshold filtering
  - [ ] Generate bounding boxes from model output
  - [ ] Add inference latency tracking
  - [ ] Unit tests for YOLOv8 integration

- [ ] Integrate density estimation counting model (AC: 2, 6)
  - [ ] Load or train density estimation CNN
  - [ ] Implement density map generation
  - [ ] Create counting logic from density maps
  - [ ] Implement post-processing to merge nearby detections
  - [ ] Add handling for overlapping/stacked materials
  - [ ] Accuracy validation against manual counts
  - [ ] Unit tests for counting model

- [ ] Implement brand detection using OCR (AC: 3)
  - [ ] Integrate Tesseract or AWS Textract
  - [ ] Create ROI cropping from detected materials
  - [ ] Implement OCR text extraction
  - [ ] Create fuzzy string matching for brand identification
  - [ ] Implement brand confidence scoring
  - [ ] Handle OCR failures gracefully
  - [ ] Unit tests for brand detection

- [ ] Implement material type classification (AC: 1)
  - [ ] Create material type classifier
  - [ ] Implement type detection from visual features
  - [ ] Create material type mapping from detection classes
  - [ ] Add confidence scoring per material type
  - [ ] Unit tests for material type classification

- [ ] Implement quantity validation and alerts (AC: 4, 5)
  - [ ] Create validation logic for expected vs. detected counts
  - [ ] Implement variance percentage calculation
  - [ ] Create alert generation for discrepancies
  - [ ] Define alert thresholds (configurable)
  - [ ] Implement alert message generation
  - [ ] Unit tests for validation logic

- [ ] Implement batch processing capability (AC: 8)
  - [ ] Create batch request handling logic
  - [ ] Implement GPU batch optimization
  - [ ] Add queue management for batch requests
  - [ ] Implement result aggregation for batch responses
  - [ ] Add progress tracking for batch jobs
  - [ ] Unit tests for batch processing

- [ ] Implement response schema and validation (AC: 10)
  - [ ] Create Pydantic models for material detection response
  - [ ] Implement response builder from model outputs
  - [ ] Add summary statistics calculation
  - [ ] Create tag generation based on detections
  - [ ] Validate response schema compliance
  - [ ] Unit tests for response schema

- [ ] Implement GPU optimization and caching (AC: 7, 8)
  - [ ] Load models on service startup
  - [ ] Implement model instance caching
  - [ ] Cache brand database in memory
  - [ ] Add GPU memory pre-allocation
  - [ ] Implement batch processing for GPU efficiency
  - [ ] Performance tests for latency benchmarking

- [ ] Implement image preprocessing pipeline
  - [ ] Handle EXIF orientation
  - [ ] Normalize images to model input format
  - [ ] Implement resolution optimization
  - [ ] Add handling for various image formats
  - [ ] Unit tests for image preprocessing

- [ ] Implement gRPC service endpoints
  - [ ] Create gRPC proto definitions
  - [ ] Implement detect_materials RPC method
  - [ ] Implement batch_detect_materials RPC method
  - [ ] Add health check gRPC method
  - [ ] Implement error handling and status codes
  - [ ] Integration tests for gRPC endpoints

- [ ] Implement monitoring and metrics
  - [ ] Create Prometheus metrics for inference latency
  - [ ] Track success/error rates per material type
  - [ ] Monitor counting accuracy metrics
  - [ ] Monitor OCR success rates
  - [ ] Track alert generation frequency
  - [ ] Create model version tracking in metrics

- [ ] Create comprehensive test suite (>80% coverage)
  - [ ] Unit tests for each model component
  - [ ] Integration tests for full pipeline
  - [ ] Performance benchmarking tests
  - [ ] Edge case tests (overlapping materials, poor lighting)
  - [ ] Test fixtures with sample delivery photos
  - [ ] Accuracy validation tests
  - [ ] GPU-aware test skipping

- [ ] Documentation and deployment guides
  - [ ] API documentation for gRPC methods
  - [ ] Model deployment and versioning guide
  - [ ] Material database maintenance guide
  - [ ] Brand database update procedures
  - [ ] Troubleshooting guide for detection issues
  - [ ] Performance tuning recommendations

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-18 | 1.0 | Initial story creation for Material Detection Engine | Scrum Master |

---
