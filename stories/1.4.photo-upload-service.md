# Story 1.4: Photo Upload Service with S3 Integration

**Status:** Ready for Development

---

## Story

**As a** Mobile/Web Client,
**I want** to upload photos through a dedicated service that generates secure pre-signed URLs and manages photo metadata,
**so that** I can securely store photos in S3 and trigger the detection pipeline without exposing AWS credentials.

---

## Acceptance Criteria

1. Photo Upload Service API endpoint `/api/v1/photos/upload-url` generates pre-signed S3 URLs with 15-minute expiration
2. Pre-signed URL generation respects photo size limits and validates MIME types (JPEG, PNG)
3. Photo metadata (EXIF data, dimensions, file size) is extracted and stored in database after successful S3 upload
4. Service validates JWT token and enforces authorization (users can only upload to their projects)
5. Photo Upload Service triggers detection pipeline via message queue after S3 upload confirmation
6. Service handles S3 upload failures gracefully with retry logic and error reporting
7. Uploaded photo records have status field: `uploaded`, `processing`, `completed`, `failed`
8. API response includes photo ID, S3 URL, and detection status polling endpoint

---

## Dev Notes

### Photo Upload Service Architecture
- **Technology**: Python FastAPI (or Node.js Express) with boto3/AWS SDK for S3 operations [Source: architecture.md#4.3-Photo-Upload-Service]
- **Purpose**: Receive upload requests, generate secure pre-signed URLs, trigger detection pipeline [Source: architecture.md#4.3-Photo-Upload-Service]
- **Responsibilities**:
  - Generate pre-signed S3 URLs for direct client uploads
  - Extract and validate photo metadata (EXIF)
  - Store photo records in PostgreSQL
  - Trigger detection pipeline via SQS message queue [Source: architecture.md#5.1-Photo-Upload-and-Detection-Flow]

### Pre-Signed URL Generation
- **Endpoint**: `POST /api/v1/photos/upload-url`
- **Request Payload**:
  ```json
  {
    "project_id": "uuid",
    "file_name": "roof_damage_001.jpg",
    "file_size": 2048576,
    "mime_type": "image/jpeg"
  }
  ```
- **Response**:
  ```json
  {
    "upload_id": "uuid",
    "s3_url": "https://companycam-photos-prod.s3.amazonaws.com/...",
    "upload_url": "https://companycam-photos-prod.s3.amazonaws.com/...",
    "expires_in_seconds": 900
  }
  ```
- **Validation Rules**:
  - Maximum file size: 50MB (configurable)
  - Allowed MIME types: `image/jpeg`, `image/png`
  - User must be authenticated with valid JWT token
  - User must have access to the project (same organization)

### S3 Integration Details
- **Bucket**: `companycam-photos-{environment}` from Story 1.2
- **Key Structure**: `{project_id}/{year}/{month}/{day}/{photo_id}.{extension}`
- **Pre-Signed URL Expiration**: 15 minutes (900 seconds)
- **Upload Headers**: Content-Type validation, Content-Length limits
- **Access Control**: Service role has S3:PutObject permission, clients use pre-signed URLs

### EXIF Data Extraction
- **Tool**: PIL/Pillow (Python) or Sharp (Node.js) with EXIF parsing
- **Extracted Fields**:
  - Camera make/model
  - GPS coordinates (if available)
  - Timestamp (photo capture time)
  - Orientation
  - Image dimensions
- **Storage**: Store as JSONB in photos table `exif_data` column

### Photo Status Lifecycle
```
pending_upload → uploaded → processing → completed/failed
```
- `pending_upload`: Pre-signed URL generated, waiting for client upload
- `uploaded`: Photo successfully stored in S3
- `processing`: Detection pipeline triggered, waiting for results
- `completed`: Detection processing finished
- `failed`: Upload or processing failed with error details

### Message Queue Trigger
- **Queue**: AWS SQS (or RabbitMQ for development)
- **Message Format**:
  ```json
  {
    "photo_id": "uuid",
    "s3_url": "s3://bucket/path/photo.jpg",
    "detection_types": ["damage", "material"],
    "priority": "normal"
  }
  ```
- **Trigger**: Published after photo metadata saved to database
- **Publishing**: Use boto3 SQS client with error handling

### Error Handling and Retry Logic
- **S3 Connection Errors**: Retry 3 times with exponential backoff (1s, 2s, 4s)
- **EXIF Extraction Failures**: Log error, continue without EXIF data
- **Database Errors**: Transaction rollback, return 500 error to client
- **Message Queue Failures**: Log error, store for manual retry

### API Endpoints

#### Generate Upload URL
```
POST /api/v1/photos/upload-url
Authorization: Bearer {jwt_token}
Content-Type: application/json

{
  "project_id": "uuid",
  "file_name": "damage.jpg",
  "file_size": 2097152,
  "mime_type": "image/jpeg"
}

Response 200:
{
  "upload_id": "uuid",
  "photo_id": "uuid",
  "upload_url": "https://s3.amazonaws.com/...",
  "s3_url": "https://companycam-photos.s3.amazonaws.com/...",
  "expires_in_seconds": 900,
  "headers": {
    "Content-Type": "image/jpeg"
  }
}
```

#### Get Photo Status
```
GET /api/v1/photos/{photo_id}
Authorization: Bearer {jwt_token}

Response 200:
{
  "id": "uuid",
  "project_id": "uuid",
  "s3_url": "https://...",
  "status": "processing",
  "uploaded_at": "2025-11-17T10:30:00Z",
  "exif_data": {
    "camera_make": "Canon",
    "gps_coordinates": {...}
  }
}
```

### Testing Standards
- **Unit Tests**:
  - Pre-signed URL generation logic (mock S3)
  - EXIF extraction from sample photos
  - Photo status transitions
  - Input validation (file size, MIME type)
- **Integration Tests**:
  - Full upload flow with test S3 bucket (moto for mocking)
  - Database photo record creation
  - SQS message publishing
  - Authorization checks
- **Test Coverage**: >85% for upload service
- **Test Data**: Sample JPEG/PNG files with and without EXIF data
- **Test Framework**: Pytest (Python) or Jest (Node.js)

---

## Tasks / Subtasks

- [ ] Create Photo Upload Service base structure (AC: 1)
  - [ ] Create `/backend/src/services/photo_upload_service.py` (Python) or `photoUploadService.ts` (Node.js)
  - [ ] Set up FastAPI/Express router with authentication middleware
  - [ ] Import and configure boto3 AWS S3 client with environment-based credentials
  - [ ] Create configuration for S3 bucket name, region, expiration times
  - [ ] Test service instantiation and S3 client connection

- [ ] Implement Pre-Signed URL Generation (AC: 1, 2)
  - [ ] Create `generate_upload_url()` function to create pre-signed URLs
  - [ ] Implement file validation: MIME type checking (JPEG, PNG only)
  - [ ] Implement file size validation (max 50MB, minimum 1KB)
  - [ ] Set 15-minute expiration on pre-signed URLs
  - [ ] Include Content-Type header constraint in pre-signed URL
  - [ ] Test URL generation with various file sizes and types
  - [ ] Document rate limiting: max 100 URLs per user per minute

- [ ] Implement Photo Upload Endpoint (AC: 1, 4, 8)
  - [ ] Create `POST /api/v1/photos/upload-url` endpoint
  - [ ] Add JWT authorization middleware to endpoint
  - [ ] Validate request: project_id exists, user has access, file_name provided
  - [ ] Generate unique photo ID (UUID)
  - [ ] Call S3 pre-signed URL generation
  - [ ] Return response with upload_url, photo_id, expiration
  - [ ] Add request/response logging with correlation IDs
  - [ ] Test endpoint with invalid tokens and unauthorized projects

- [ ] Implement EXIF Data Extraction (AC: 3)
  - [ ] Create EXIF extraction utility using PIL/Pillow (Python) or Sharp (Node.js)
  - [ ] Extract fields: camera make/model, GPS, timestamp, orientation, dimensions
  - [ ] Handle photos with missing EXIF data gracefully
  - [ ] Create function to parse EXIF binary data and convert to JSON
  - [ ] Test with sample photos (with and without EXIF)
  - [ ] Document EXIF field mapping and storage format

- [ ] Implement Photo Metadata Storage (AC: 3, 7)
  - [ ] Create database model/migration for photo metadata (see Story 1.3)
  - [ ] Implement function to save photo record to PostgreSQL
  - [ ] Store: photo_id, user_id, project_id, s3_url, s3_key, file_size, dimensions, exif_data, status
  - [ ] Initialize status as `pending_upload`
  - [ ] Test photo record creation with valid and invalid data
  - [ ] Verify database constraints and unique S3 key

- [ ] Implement Message Queue Integration (AC: 5)
  - [ ] Create SQS client initialization with boto3
  - [ ] Create function to publish photo processing message to queue
  - [ ] Message format: photo_id, s3_url, detection_types, priority
  - [ ] Add error handling with retry logic (3 retries, exponential backoff)
  - [ ] Implement fallback: log error if queue unavailable, don't fail upload
  - [ ] Test message publishing with mocked SQS

- [ ] Implement Photo Status Tracking (AC: 7)
  - [ ] Add `status` column to photos table (pending_upload, uploaded, processing, completed, failed)
  - [ ] Create functions to transition status: mark_uploaded(), mark_processing(), mark_completed()
  - [ ] Implement status update API: `PATCH /api/v1/photos/{photo_id}/status`
  - [ ] Add timestamp tracking for each status change
  - [ ] Test status transitions and workflow

- [ ] Implement Photo Status Polling Endpoint (AC: 8)
  - [ ] Create `GET /api/v1/photos/{photo_id}` endpoint
  - [ ] Return photo metadata and current status
  - [ ] Include S3 URL for client display
  - [ ] Include detection status (if processing or completed)
  - [ ] Add authorization check (user can only view their photos)
  - [ ] Test endpoint with various photo statuses

- [ ] Implement Error Handling and Retry Logic (AC: 6)
  - [ ] Create custom exceptions: InvalidFileType, FileTooLarge, S3ConnectionError, UnauthorizedAccess
  - [ ] Implement retry logic for S3 operations (exponential backoff)
  - [ ] Create error response format consistent with API standards
  - [ ] Log errors with context: photo_id, user_id, error type
  - [ ] Test error scenarios: network failure, S3 access denied, invalid tokens

- [ ] Create Integration Tests (AC: 1-8)
  - [ ] Set up test fixtures: test users, projects, S3 mock (moto)
  - [ ] Test full upload flow: generate URL → upload → store metadata → publish message
  - [ ] Test authorization: prevent cross-project uploads, invalid tokens
  - [ ] Test file validation: reject oversized files, invalid MIME types
  - [ ] Test EXIF extraction with sample images
  - [ ] Test error scenarios: S3 failures, database errors, message queue failures
  - [ ] Achieve >85% test coverage

- [ ] Create API Documentation (AC: 8)
  - [ ] Document endpoint: `/api/v1/photos/upload-url` (parameters, responses, errors)
  - [ ] Document endpoint: `GET /api/v1/photos/{photo_id}` (parameters, responses)
  - [ ] Include example requests and responses
  - [ ] Document error codes and troubleshooting
  - [ ] Add SDK examples for client integration (JavaScript, React Native)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-17 | 1.0 | Initial story creation for photo upload service | Bob (Scrum Master) |

---

## Dev Agent Record

*To be populated by development agent during implementation*

### Agent Model Used
TBD

### Debug Log References
TBD

### Completion Notes
TBD

### File List
TBD

---

## QA Results

*To be populated by QA agent after development*
